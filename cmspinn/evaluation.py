# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/26_evaluation.ipynb.

# %% auto 0
__all__ = ['magnitude', 'gradient', 'divergence', 'curl', 'laplacian', 'laplacian_vector', 'magnetic_energy']

# %% ../nbs/26_evaluation.ipynb 8
import numpy as np

# %% ../nbs/26_evaluation.ipynb 9
def magnitude(vector):
    return np.sqrt((vector**2).sum(-1))

def gradient(scalar, dx=None, dy=None, dz=None):

    if (dx is not None) and (dy is not None) and (dz is not None):
        Dx_scalar, Dy_scalar, Dz_scalar = np.gradient(scalar, dx, dy, dz, axis=[0, 1, 2], edge_order=2)
    else:
        Dx_scalar, Dy_scalar, Dz_scalar = np.gradient(scalar, axis=[0, 1, 2], edge_order=2)

    return np.stack([Dx_scalar, Dy_scalar, Dz_scalar], axis=-1)
    
def divergence(vector, dx=None, dy=None, dz=None):
    vector_x, vector_y, vector_z = vector[..., 0], vector[..., 1], vector[..., 2]

    if (dx is not None) and (dy is not None) and (dz is not None):
        Dx_vector_x = np.gradient(vector_x, dx, axis=[0], edge_order=2)
        Dy_vector_y = np.gradient(vector_y, dy, axis=[1], edge_order=2)
        Dz_vector_z = np.gradient(vector_z, dz, axis=[2], edge_order=2)
    else:
        Dx_vector_x = np.gradient(vector_x, axis=[0], edge_order=2)
        Dy_vector_y = np.gradient(vector_y, axis=[1], edge_order=2)
        Dz_vector_z = np.gradient(vector_z, axis=[2], edge_order=2)

    return Dx_vector_x + Dy_vector_y + Dz_vector_z

def curl(vector, dx=None, dy=None, dz=None):
    vector_x, vector_y, vector_z = vector[..., 0], vector[..., 1], vector[..., 2]

    if (dx is not None) and (dy is not None) and (dz is not None):
        Dy_vector_x, Dz_vector_x = np.gradient(vector_x, dy, dz, axis=[1, 2], edge_order=2)
        Dx_vector_y, Dz_vector_y = np.gradient(vector_y, dx, dz, axis=[0, 2], edge_order=2)
        Dx_vector_z, Dy_vector_z = np.gradient(vector_z, dx, dy, axis=[0, 1], edge_order=2)
    else:
        Dy_vector_x, Dz_vector_x = np.gradient(vector_x, axis=[1, 2], edge_order=2)
        Dx_vector_y, Dz_vector_y = np.gradient(vector_y, axis=[0, 2], edge_order=2)
        Dx_vector_z, Dy_vector_z = np.gradient(vector_z, axis=[0, 1], edge_order=2)
    
    curl_x = Dy_vector_z - Dz_vector_y 
    curl_y = Dz_vector_x - Dx_vector_z
    curl_z = Dx_vector_y - Dy_vector_x

    return np.stack([curl_x, curl_y, curl_z], axis=-1)

def laplacian(scalar, dx=None, dy=None, dz=None):
    if (dx is not None) and (dy is not None) and (dz is not None):
        gradient_scalar = gradient(scalar, dx, dy, dz)
        Dx_scalar = gradient_scalar[..., 0]
        Dy_scalar = gradient_scalar[..., 1]
        Dz_scalar = gradient_scalar[..., 2]

        Dx_Dx_scalar = np.gradient(Dx_scalar, dx, axis=[0], edge_order=2)
        Dy_Dy_scalar = np.gradient(Dy_scalar, dy, axis=[1], edge_order=2)
        Dz_Dz_scalar = np.gradient(Dz_scalar, dz, axis=[2], edge_order=2)
    else:
        gradient_scalar = gradient(scalar)
        Dx_scalar = gradient_scalar[..., 0]
        Dy_scalar = gradient_scalar[..., 1]
        Dz_scalar = gradient_scalar[..., 2]

        Dx_Dx_scalar = np.gradient(Dx_scalar, axis=[0], edge_order=2)
        Dy_Dy_scalar = np.gradient(Dy_scalar, axis=[1], edge_order=2)
        Dz_Dz_scalar = np.gradient(Dz_scalar, axis=[2], edge_order=2)

    return Dx_Dx_scalar + Dy_Dy_scalar + Dz_Dz_scalar

def laplacian_vector(vector, dx=None, dy=None, dz=None):
    vector_x, vector_y, vector_z = vector[..., 0], vector[..., 1], vector[..., 2]

    if (dx is not None) and (dy is not None) and (dz is not None):
        laplacian_vector_x = laplacian(vector_x, dx, dy, dz)
        laplacian_vector_y = laplacian(vector_y, dx, dy, dz)
        laplacian_vector_z = laplacian(vector_z, dx, dy, dz)
    else:
        laplacian_vector_x = laplacian(vector_x)
        laplacian_vector_y = laplacian(vector_y)
        laplacian_vector_z = laplacian(vector_z)

    return np.stack([laplacian_vector_x, laplacian_vector_y, laplacian_vector_z], axis=-1)

def magnetic_energy(magnetic_field_vector):
    return (magnetic_field_vector**2).sum(-1) / (8*np.pi)
