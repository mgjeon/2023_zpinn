# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/08_Potential_Field.ipynb.

# %% auto 0
__all__ = ['PotentialModel', 'get_potential', 'get_potential_field', 'potential_cube', 'get_potential_boundary',
           'cal_and_save_potential_boundary_for_spinn', 'cal_potential_boundary_for_spinn']

# %% ../nbs/08_Potential_Field.ipynb 5
import numpy as np
import torch
from astropy.nddata import block_replicate
from torch import nn
from torch.utils.data import DataLoader, TensorDataset
from tqdm import tqdm

# %% ../nbs/08_Potential_Field.ipynb 7
class PotentialModel(nn.Module):
    def __init__(self, b_n, r_p):
        super().__init__()
        self.register_buffer('b_n', b_n)
        self.register_buffer('r_p', r_p)
        c = np.zeros((1, 3))
        c[:, 2] = (1 / np.sqrt(2 * np.pi))
        c = torch.tensor(c, dtype=torch.float32, )
        self.register_buffer('c', c)

    def forward(self, coord):
        v1 = self.b_n[:, None]
        v2 = 2 * np.pi * ((-self.r_p[:, None] + coord[None, :] + self.c[None]) ** 2).sum(-1) ** 0.5
        potential = torch.sum(v1 / v2, dim=0)
        return potential


def get_potential(b_n, height, batch_size=2048, strides=(1, 1, 1), progress=True):
    cube_shape = (*b_n.shape, height)
    strides = (strides, strides, strides) if isinstance(strides, int) else strides
    b_n = b_n.reshape((-1,)).astype(np.float32)
    coords = np.stack(np.mgrid[:cube_shape[0]:strides[0], :cube_shape[1]:strides[1], :cube_shape[2]:strides[2]], -1).reshape((-1, 3))
    r_p = np.stack(np.mgrid[:cube_shape[0], :cube_shape[1], :1], -1).reshape((-1, 3))

    # torch code
    # r = (x * y, 3); coords = (x*y*z, 3), c = (1, 3)
    # --> (x * y, x * y * z, 3) --> (x * y, x * y * z) --> (x * y * z)
    device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')
    with torch.no_grad():
        b_n = torch.tensor(b_n, dtype=torch.float32, )
        r_p = torch.tensor(r_p, dtype=torch.float32, )
        model = nn.DataParallel(PotentialModel(b_n, r_p)).to(device)

        coords = torch.tensor(coords, dtype=torch.float32)
        potential = []
        loader = DataLoader(TensorDataset(coords), batch_size=batch_size, num_workers=0)
        it = tqdm(loader, desc='Potential Field') if progress else loader
        for coord, in it:
            coord = coord.to(device)
            p_batch = model(coord)
            potential += [p_batch]

    potential = torch.cat(potential).view(cube_shape).cpu().numpy()
    if strides != (1, 1, 1):
        potential = block_replicate(potential, strides, conserve_sum=False)
    return potential

def get_potential_field(b_n, height, *args, **kwargs):
    potential = get_potential(b_n, height, *args, **kwargs)
    b = - 1 * np.stack(np.gradient(potential, axis=[0, 1, 2], edge_order=2), axis=-1)
    return b

# %% ../nbs/08_Potential_Field.ipynb 14
from .mag_viz import create_coordinates
import pyvista as pv
import os

# %% ../nbs/08_Potential_Field.ipynb 15
class potential_cube:
    def __init__(self, bz_bottom, Nz):
        self.bz_bottom = bz_bottom
        self.Nz = Nz

        self.Nx, self.Ny = bz_bottom.shape

    def cal_and_save_potential_field(self, vtk_path, batch_size=10000):
        if os.path.exists(vtk_path):
            print(f'Exist {vtk_path}')
            return
        bz_bottom = self.bz_bottom
        Nx, Ny, Nz = self.Nx, self.Ny, self.Nz

        B_pot = get_potential_field(bz_bottom, Nz, batch_size=batch_size)
        
        Bx = B_pot[..., 0]
        By = B_pot[..., 1]
        Bz = B_pot[..., 2]

        co_bounds = (0, Nx-1, 0, Ny-1, 0, Nz-1)
        co_coords = create_coordinates(co_bounds).reshape(-1, 3)
        co_coord = co_coords.reshape(Nx, Ny, Nz, 3)
        x = co_coord[..., 0]
        y = co_coord[..., 1]
        z = co_coord[..., 2]
        mesh = pv.StructuredGrid(x, y, z)
        vectors = np.stack([Bx, By, Bz], axis=-1).transpose(2, 1, 0, 3).reshape(-1, 3)
        mesh['B'] = vectors
        mesh.active_vectors_name = 'B'
        magnitude = np.linalg.norm(vectors, axis=-1)
        mesh['mag'] = magnitude
        mesh.active_scalars_name = 'mag'

        self.grid = mesh 
        self.grid.save(vtk_path)
        return self.grid

# %% ../nbs/08_Potential_Field.ipynb 30
def get_potential_boundary(b_n, height, batch_size=2048, **kwargs):
    assert not np.any(np.isnan(b_n)), 'Invalid data value'

    cube_shape = (*b_n.shape, height)

    b_n = b_n.reshape((-1)).astype(np.float32)
    coords = [np.stack(np.mgrid[:cube_shape[0], :cube_shape[1], cube_shape[2] - 2:cube_shape[2] + 1], -1),       #top
              np.stack(np.mgrid[:cube_shape[0], -1:2, :cube_shape[2]], -1),                                      #y=0
              np.stack(np.mgrid[:cube_shape[0], cube_shape[1] - 2:cube_shape[1] + 1, :cube_shape[2]], -1),       #y=max
              np.stack(np.mgrid[-1:2, :cube_shape[1], :cube_shape[2]], -1),                                      #x=0
              np.stack(np.mgrid[cube_shape[0] - 2:cube_shape[0] + 1, :cube_shape[1], :cube_shape[2]], -1), ]     #x=max
    fields = _compute_fields(coords, cube_shape, b_n, batch_size=batch_size, **kwargs)

    fields = [fields[0][:, :, 1],
              fields[1][:, 1, :], fields[2][:, 1, :],
              fields[3][1, :, :], fields[4][1, :, :]]
    coords = [coords[0][:, :, 1],
              coords[1][:, 1, :], coords[2][:, 1, :],
              coords[3][1, :, :], coords[4][1, :, :]]
    return coords, fields

def _compute_fields(coords, cube_shape, b_n, batch_size=2048, progress=False):
    coords_shape = [c.shape[:-1] for c in coords]
    flat_coords = np.concatenate([c.reshape(((-1, 3))) for c in coords])

    r_p = np.stack(np.mgrid[:cube_shape[0], :cube_shape[1], :1], -1).reshape((-1, 3))

    # torch code
    # r = (x * y, 3); coords = (x*y*z, 3), c = (1, 3)
    # --> (x * y, x * y * z, 3) --> (x * y, x * y * z) --> (x * y * z)
    device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')
    with torch.no_grad():
        b_n = torch.tensor(b_n, dtype=torch.float32, )
        r_p = torch.tensor(r_p, dtype=torch.float32, )
        model = nn.DataParallel(PotentialModel(b_n, r_p, )).to(device)

        flat_coords = torch.tensor(flat_coords, dtype=torch.float32, )

        potential = []
        iter = DataLoader(TensorDataset(flat_coords), batch_size=batch_size, num_workers=0)
        iter = iter if progress else tqdm(iter, desc='Potential Boundary')
        for coord, in iter:
            coord = coord.to(device)
            p_batch = model(coord)
            potential += [p_batch.cpu()]

    potential = torch.cat(potential).numpy()
    idx = 0
    fields = []
    for s in coords_shape:
        p = potential[idx:idx + np.prod(s)].reshape(s)
        b = - 1 * np.stack(np.gradient(p, axis=[0, 1, 2], edge_order=2), axis=-1)
        fields += [b]
        idx += np.prod(s)

    return fields

# %% ../nbs/08_Potential_Field.ipynb 31
import pickle

# %% ../nbs/08_Potential_Field.ipynb 32
def cal_and_save_potential_boundary_for_spinn(b_bottom, Nz, b_norm, boundary_path, batch_size=2048):
    bz_bottom = b_bottom[:, :, 2]

    coords, fields = get_potential_boundary(b_bottom[:, :, 2], Nz, batch_size=batch_size)

    #0 z=0   bottom
    #1 z=2   top                  
    #2 x=0   lateral_1            
    #3 x=2   lateral_2            
    #4 y=0   lateral_3            
    #5 y=2   lateral_4    

    bp_top = fields[0]
    bp_lateral_3 = fields[1]
    bp_lateral_4 = fields[2]
    bp_lateral_1 = fields[3]
    bp_lateral_2 = fields[4]

    b_bottom_norm = b_bottom / b_norm
    bp_top_norm = bp_top / b_norm
    bp_lateral_1_norm = bp_lateral_1 / b_norm
    bp_lateral_2_norm = bp_lateral_2 / b_norm
    bp_lateral_3_norm = bp_lateral_3 / b_norm 
    bp_lateral_4_norm = bp_lateral_4 / b_norm

    boundary_data = (b_bottom_norm, bp_top_norm, bp_lateral_1_norm, bp_lateral_2_norm, bp_lateral_3_norm, bp_lateral_4_norm)

    with open(boundary_path, "wb") as f:
        pickle.dump(boundary_data, f)

# %% ../nbs/08_Potential_Field.ipynb 33
def cal_potential_boundary_for_spinn(b_bottom, Nz, b_norm):
    bz_bottom = b_bottom[:, :, 2]

    coords, fields = get_potential_boundary(b_bottom[:, :, 2], Nz)

    #0 z=0   bottom
    #1 z=2   top                  
    #2 x=0   lateral_1            
    #3 x=2   lateral_2            
    #4 y=0   lateral_3            
    #5 y=2   lateral_4    

    bp_top = fields[0]
    bp_lateral_3 = fields[1]
    bp_lateral_4 = fields[2]
    bp_lateral_1 = fields[3]
    bp_lateral_2 = fields[4]

    b_bottom_norm = b_bottom / b_norm
    bp_top_norm = bp_top / b_norm
    bp_lateral_1_norm = bp_lateral_1 / b_norm
    bp_lateral_2_norm = bp_lateral_2 / b_norm
    bp_lateral_3_norm = bp_lateral_3 / b_norm 
    bp_lateral_4_norm = bp_lateral_4 / b_norm

    boundary_data = (b_bottom_norm, bp_top_norm, bp_lateral_1_norm, bp_lateral_2_norm, bp_lateral_3_norm, bp_lateral_4_norm)

    return boundary_data
