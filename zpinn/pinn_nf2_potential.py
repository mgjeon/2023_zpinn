# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_PINN_NF2_potential_field.ipynb.

# %% auto 0
__all__ = ['get_potential_field']

# %% ../nbs/07_PINN_NF2_potential_field.ipynb 2
import pickle
import numpy as np
import torch
from torch import nn
from torch.utils.data import DataLoader, TensorDataset
from tqdm import tqdm

from .pinn_nf2_cleanup import PotentialModel, create_coordinates
from .pinn_nf2_visualization import create_physical_coordinates

# %% ../nbs/07_PINN_NF2_potential_field.ipynb 3
class get_potential_field:
    def __init__(self, b, height):
        Nx, Ny, _ =  b.grid.dimensions
        bottom_subset = (0, Nx-1, 0, Ny-1, 0, 0)
        bottom = b.grid.extract_subset(bottom_subset).extract_surface()
        b_bottom = bottom['B'].reshape(Nx, Ny, 3)
        self.b_bottom = np.array(b_bottom)

        self.height = height

    def calculate_potential_fields(self):
        b_bottom = self.b_bottom
        height = self.height
        
        Nx, Ny, _ = b_bottom.shape
        Nz = height
        
        bottom_values = b_bottom.reshape(-1, 3)
        bottom_bounds = (0, Nx-1, 0, Ny-1, 0, 0)
        bottom_coords = create_coordinates(bottom_bounds).reshape(-1, 3)
    
        b_n = torch.tensor(bottom_values[:, 2], dtype=torch.float64)
        r_p = torch.tensor(bottom_coords, dtype=torch.float64)

        device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')
        model = nn.DataParallel(PotentialModel(b_n, r_p)).to(device)

        domain_bounds = (0, Nx-1, 0, Ny-1, 0, Nz-1)
        resolutions = (Nx, Ny, Nz)
        grid = create_physical_coordinates(domain_bounds, resolutions)
        domain_coords = np.array(grid.points)
        domain_coords = torch.tensor(domain_coords)

        batch_size = int(np.prod(domain_coords.shape[:-1]) // 200)
        
        cube = []
        for r, in tqdm(DataLoader(TensorDataset(domain_coords), batch_size=batch_size, num_workers=8),
                            desc='Potential Field'):
            r = r.to(device).requires_grad_(True)
            p_batch = model(r)
            b_p = -1 * torch.autograd.grad(p_batch, r, torch.ones_like(p_batch), retain_graph=True, create_graph=True)[0]
            cube += [b_p.clone().detach().cpu()]
        cube = torch.concatenate(cube)
        B = cube.numpy()
                                
        Bx = B[:, 0]
        By = B[:, 1]
        Bz = B[:, 2]

        vectors = np.empty((grid.n_points, 3))
        vectors[:, 0] = Bx
        vectors[:, 1] = By
        vectors[:, 2] = Bz
        grid['B'] = vectors
        grid.active_vectors_name = 'B'
        magnitude = np.linalg.norm(vectors, axis=-1)
        grid['mag'] = magnitude
        grid.active_scalars_name = 'mag'

        self.grid = grid
        return self.grid
