# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_PINN_NF2_potential_field.ipynb.

# %% auto 0
__all__ = ['get_potential_field_numpy', 'get_potential_field']

# %% ../nbs/07_PINN_NF2_potential_field.ipynb 2
import pickle
import numpy as np
import torch
from torch import nn
from torch.utils.data import DataLoader, TensorDataset
from tqdm import tqdm
import pyvista as pv

from .pinn_nf2_cleanup import PotentialModel, create_coordinates
from .pinn_nf2_visualization import create_physical_coordinates

# %% ../nbs/07_PINN_NF2_potential_field.ipynb 3
class get_potential_field_numpy:
    def __init__(self, b, height):
        Nx, Ny, _ =  b.grid.dimensions
        bottom_subset = (0, Nx-1, 0, Ny-1, 0, 0)
        bottom = b.grid.extract_subset(bottom_subset).extract_surface()
        b_bottom = bottom['B'].reshape(Nx, Ny, 3)
        self.b_bottom = np.array(b_bottom)
        self.height = height

    def get_potential(self, b_n, height, batch_size=2048, strides=(1, 1, 1), progress=True):
        cube_shape = (*b_n.shape, height)
        strides = (strides, strides, strides) if isinstance(strides, int) else strides
        b_n = b_n.reshape((-1,)).astype(np.float32)
        coords = np.stack(np.mgrid[:cube_shape[0]:strides[0], :cube_shape[1]:strides[1], :cube_shape[2]:strides[2]], -1).reshape((-1, 3))
        r_p = np.stack(np.mgrid[:cube_shape[0], :cube_shape[1], :1], -1).reshape((-1, 3))

        # torch code
        # r = (x * y, 3); coords = (x*y*z, 3), c = (1, 3)
        # --> (x * y, x * y * z, 3) --> (x * y, x * y * z) --> (x * y * z)
        device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')
        with torch.no_grad():
            b_n = torch.tensor(b_n, dtype=torch.float32, )
            r_p = torch.tensor(r_p, dtype=torch.float32, )
            model = nn.DataParallel(PotentialModel(b_n, r_p)).to(device)

            coords = torch.tensor(coords, dtype=torch.float32)
            potential = []
            loader = DataLoader(TensorDataset(coords), batch_size=batch_size, num_workers=8)
            it = tqdm(loader, desc='Potential Field') if progress else loader
            for coord, in it:
                coord = coord.to(device)
                p_batch = model(coord)
                potential += [p_batch]

        potential = torch.cat(potential).view(cube_shape).cpu().numpy()
        return potential

    def calculate_potential_fields(self):
        potential = self.get_potential(self.b_bottom[:, :, 2], self.height)

        B = - 1 * np.stack(np.gradient(potential, axis=[0, 1, 2], edge_order=2), axis=-1)

        Bx = B[..., 0]
        By = B[..., 1]
        Bz = B[..., 2]
        
        Nx, Ny, _ = self.b_bottom.shape
        Nz = self.height

        co_bounds = (0, Nx-1, 0, Ny-1, 0, Nz-1)
        co_coords = create_coordinates(co_bounds).reshape(-1, 3)
        co_coord = co_coords.reshape(Nx, Ny, Nz, 3)
        x = co_coord[..., 0]
        y = co_coord[..., 1]
        z = co_coord[..., 2]
        grid = pv.StructuredGrid(x, y, z)
        vectors = np.stack([Bx, By, Bz], axis=-1).transpose(2, 1, 0, 3).reshape(-1, 3)
        grid['B'] = vectors
        grid.active_vectors_name = 'B'
        magnitude = np.linalg.norm(vectors, axis=-1)
        grid['mag'] = magnitude
        grid.active_scalars_name = 'mag'                                

        self.grid = grid
        return self.grid

# %% ../nbs/07_PINN_NF2_potential_field.ipynb 4
class get_potential_field:
    def __init__(self, b, height):
        Nx, Ny, _ =  b.grid.dimensions
        bottom_subset = (0, Nx-1, 0, Ny-1, 0, 0)
        bottom = b.grid.extract_subset(bottom_subset).extract_surface()
        b_bottom = bottom['B'].reshape(Nx, Ny, 3)
        self.b_bottom = np.array(b_bottom)

        self.height = height

    def calculate_potential_fields(self):
        b_bottom = self.b_bottom
        height = self.height
        
        Nx, Ny, _ = b_bottom.shape
        Nz = height
        
        bottom_values = b_bottom.reshape(-1, 3)
        bottom_bounds = (0, Nx-1, 0, Ny-1, 0, 0)
        bottom_coords = create_coordinates(bottom_bounds).reshape(-1, 3)
    
        b_n = torch.tensor(bottom_values[:, 2], dtype=torch.float64)
        r_p = torch.tensor(bottom_coords, dtype=torch.float64)

        device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')
        model = nn.DataParallel(PotentialModel(b_n, r_p)).to(device)

        domain_bounds = (0, Nx-1, 0, Ny-1, 0, Nz-1)
        resolutions = (Nx, Ny, Nz)
        grid = create_physical_coordinates(domain_bounds, resolutions)
        domain_coords = np.array(grid.points)
        domain_coords = torch.tensor(domain_coords)

        batch_size = int(np.prod(domain_coords.shape[:-1]) // 200)
        
        cube = []
        for r, in tqdm(DataLoader(TensorDataset(domain_coords), batch_size=batch_size, num_workers=8),
                            desc='Potential Field'):
            r = r.to(device).requires_grad_(True)
            p_batch = model(r)
            b_p = -1 * torch.autograd.grad(p_batch, r, torch.ones_like(p_batch), retain_graph=True, create_graph=True)[0]
            cube += [b_p.clone().detach().cpu()]
        cube = torch.cat(cube)
        B = cube.numpy()
                                
        Bx = B[:, 0]
        By = B[:, 1]
        Bz = B[:, 2]

        vectors = np.empty((grid.n_points, 3))
        vectors[:, 0] = Bx
        vectors[:, 1] = By
        vectors[:, 2] = Bz
        grid['B'] = vectors
        grid.active_vectors_name = 'B'
        magnitude = np.linalg.norm(vectors, axis=-1)
        grid['mag'] = magnitude
        grid.active_scalars_name = 'mag'

        self.grid = grid
        return self.grid
