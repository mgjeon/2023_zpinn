# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_PINN_NF2_visualization.ipynb.

# %% auto 0
__all__ = ['create_physical_coordinates', 'pinn_cube', 'draw_grid']

# %% ../nbs/06_PINN_NF2_visualization.ipynb 3
import torch
import numpy as np
import pyvista as pv
from tqdm import tqdm
from .pinn_nf2_cleanup import BModel, create_coordinates

# %% ../nbs/06_PINN_NF2_visualization.ipynb 5
def create_physical_coordinates(bounds, resolutions):
    x_1D = np.linspace(bounds[0], bounds[1], resolutions[0])
    y_1D = np.linspace(bounds[2], bounds[3], resolutions[1])
    z_1D = np.linspace(bounds[4], bounds[5], resolutions[2])
    x_spacing = np.diff(x_1D)[0]
    y_spacing = np.diff(y_1D)[0]
    z_spacing = np.diff(z_1D)[0]
    spacing = (x_spacing, y_spacing, z_spacing)
    origin = (x_1D[0], y_1D[0], z_1D[0]) # The bottom left corner of the data set
    grid = pv.UniformGrid(dimensions=resolutions, spacing=spacing, origin=origin)
    return grid

# %% ../nbs/06_PINN_NF2_visualization.ipynb 6
class pinn_cube:
    def __init__(self, save_path):
        self.device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')
        self.state = torch.load(save_path, map_location=self.device)
        self.model = self.state['model']
        self.cube_shape = self.state['cube_shape']
        self.b_norm = self.state['b_norm']
        self.spatial_norm = self.state['spatial_norm']
        
    def calculate_magnetic_fields(self, batch_size = 10000):
        device = self.device
        spatial_norm = self.spatial_norm
        b_norm = self.b_norm
        model = self.model
        
        Nx, Ny, Nz = self.cube_shape
        domain_bounds = (0, Nx-1, 0, Ny-1, 0, Nz-1)
        resolutions = (Nx, Ny, Nz)
        grid = create_physical_coordinates(domain_bounds, resolutions)
        domain_coords = np.array(grid.points)
        normalized_domain_coords = domain_coords / spatial_norm
        normalized_domain_coords = normalized_domain_coords.astype(np.float32)
        normalized_domain_coords = torch.tensor(normalized_domain_coords)
        n_batch = int(np.ceil(normalized_domain_coords.shape[0] / batch_size))

        cube = []
        for k in tqdm(range(n_batch)):
            batch_coords = normalized_domain_coords[k*batch_size : (k+1)*batch_size]
            batch_coords.to(device)
            cube += [model(batch_coords).detach().cpu()]
        cube = torch.concatenate(cube)
        B = cube.numpy()*b_norm
        
        Bx = B[:, 0]
        By = B[:, 1]
        Bz = B[:, 2]

        vectors = np.empty((grid.n_points, 3))
        vectors[:, 0] = Bx
        vectors[:, 1] = By
        vectors[:, 2] = Bz
        grid['B'] = vectors
        grid.active_vectors_name = 'B'
        magnitude = np.linalg.norm(vectors, axis=-1)
        grid['mag'] = magnitude
        grid.active_scalars_name = 'mag'

        self.grid = grid
        return self.grid

# %% ../nbs/06_PINN_NF2_visualization.ipynb 11
import copy
import matplotlib.pyplot as plt

# %% ../nbs/06_PINN_NF2_visualization.ipynb 14
class draw_grid:
    def __init__(self, grd):
        grid = copy.deepcopy(grd)
        self.grid = grid
        x_ind_min, y_ind_min, z_ind_min = 0, 0, 0
        Nx, Ny, Nz = self.grid.dimensions
        x_ind_max, y_ind_max, z_ind_max = Nx-1, Ny-1, Nz-1
        
        bottom_subset = (x_ind_min, x_ind_max, y_ind_min, y_ind_max, 0, 0)
        bottom = self.grid.extract_subset(bottom_subset).extract_surface()
        bottom.active_vectors_name = 'B'
        bottom.active_scalars_name = 'mag'

        self.bottom = bottom

        self.x_bottom = bottom.points[:, 0].reshape(Nx, Ny)
        self.y_bottom = bottom.points[:, 1].reshape(Nx, Ny)
        self.B_bottom = bottom['B'].reshape(Nx, Ny, 3)

    def plt_Bz(self):
        plt.close()
        fig, ax = plt.subplots(figsize=(6,6))
        CS = plt.contour(self.x_bottom, self.y_bottom, self.B_bottom[:, :, 2], 
                         origin='lower', colors='k')
        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.clabel(CS, fontsize=9, inline=True)
        ax.set_title(r"$B_z(z=0)$")
        plt.show()

    def pv_bottom(self):
        p = pv.Plotter()
        p.show_bounds()
        p.add_mesh(self.grid.outline())
        p.add_mesh(self.bottom)
        p.show()

    def pv_Bz_2D(self):
        p = pv.Plotter()
        p.show_bounds()
        p.add_mesh(self.grid.outline())
        sargs = dict(title="B_z")
        ctr = self.bottom.contour(scalars=self.bottom['B'][:, 2])
        p.add_mesh(ctr, cmap='plasma', scalar_bar_args=sargs)
        p.show()

    def pv_Bz_3D(self):
        p = pv.Plotter()
        p.show_bounds()
        p.add_mesh(self.grid.outline())
        sargs = dict(title="B_z")
        ctr = self.grid.contour(scalars=self.grid['B'][:, 2])
        p.add_mesh(ctr, cmap='plasma', scalar_bar_args=sargs, opacity=0.5)
        p.show()

    def pv_streamline(self):
        p = pv.Plotter()
        p.show_bounds()
        p.add_mesh(self.grid.outline())
        i_size = self.grid.bounds[1]-self.grid.bounds[0]
        j_size = self.grid.bounds[3]-self.grid.bounds[2]
        seed = pv.Plane(center=(self.grid.center[0], self.grid.center[1], 0), direction=(0,0,1), 
                i_size=i_size, j_size=j_size, 
                i_resolution=10, j_resolution=10)
        p.add_mesh(seed)
        strl = self.grid.streamlines_from_source(seed,
                                                 vectors='B',
                                                 max_time=180,
                                                 initial_step_length=0.1,
                                                 integration_direction='both')
        
        p.add_mesh(strl.tube(radius=i_size/400), cmap='bwr', ambient=0.2)

        sargs = dict(title="B_z")
        ctr = self.bottom.contour(scalars=self.bottom['B'][:, 2])
        p.add_mesh(ctr, cmap='plasma', scalar_bar_args=sargs)
        p.show()

