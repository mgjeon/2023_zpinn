# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_PINN_NF2_visualization.ipynb.

# %% auto 0
__all__ = ['create_physical_coordinates', 'pinn_cube', 'draw_grid']

# %% ../nbs/06_PINN_NF2_visualization.ipynb 3
import os
import torch
import numpy as np
import pyvista as pv
from tqdm import tqdm
from .pinn_nf2_cleanup import BModel, create_coordinates

# %% ../nbs/06_PINN_NF2_visualization.ipynb 6
def create_physical_coordinates(bounds, resolutions):
    x_1D = np.linspace(bounds[0], bounds[1], resolutions[0])
    y_1D = np.linspace(bounds[2], bounds[3], resolutions[1])
    z_1D = np.linspace(bounds[4], bounds[5], resolutions[2])
    x_spacing = np.diff(x_1D)[0]
    y_spacing = np.diff(y_1D)[0]
    z_spacing = np.diff(z_1D)[0]
    spacing = (x_spacing, y_spacing, z_spacing)
    origin = (x_1D[0], y_1D[0], z_1D[0]) # The bottom left corner of the data set
    grid = pv.ImageData(dimensions=resolutions, spacing=spacing, origin=origin)
    return grid

# %% ../nbs/06_PINN_NF2_visualization.ipynb 7
class pinn_cube:
    def __init__(self, save_path):
        self.device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')
        self.state = torch.load(save_path, map_location=self.device)
        self.model = self.state['model']
        self.cube_shape = self.state['cube_shape']
        self.b_norm = self.state['b_norm']
        self.spatial_norm = self.state['spatial_norm']
        
    def calculate_magnetic_fields(self, batch_size = 10000):
        device = self.device
        spatial_norm = self.spatial_norm
        b_norm = self.b_norm
        model = self.model
        
        Nx, Ny, Nz = self.cube_shape
        domain_bounds = (0, Nx-1, 0, Ny-1, 0, Nz-1)
        resolutions = (Nx, Ny, Nz)
        grid = create_physical_coordinates(domain_bounds, resolutions)
        domain_coords = np.array(grid.points)
        normalized_domain_coords = domain_coords / spatial_norm
        normalized_domain_coords = normalized_domain_coords.astype(np.float32)
        normalized_domain_coords = torch.tensor(normalized_domain_coords)
        n_batch = int(np.ceil(normalized_domain_coords.shape[0] / batch_size))

        cube = []
        for k in tqdm(range(n_batch)):
            batch_coords = normalized_domain_coords[k*batch_size : (k+1)*batch_size]
            batch_coords.to(device)
            cube += [model(batch_coords).detach().cpu()]
        cube = torch.cat(cube)
        B = cube.numpy()*b_norm
        
        Bx = B[:, 0]
        By = B[:, 1]
        Bz = B[:, 2]

        vectors = np.empty((grid.n_points, 3))
        vectors[:, 0] = Bx
        vectors[:, 1] = By
        vectors[:, 2] = Bz
        grid['B'] = vectors
        grid.active_vectors_name = 'B'
        magnitude = np.linalg.norm(vectors, axis=-1)
        grid['mag'] = magnitude
        grid.active_scalars_name = 'mag'

        self.grid = grid
        return self.grid

# %% ../nbs/06_PINN_NF2_visualization.ipynb 12
import copy
import matplotlib.pyplot as plt

# %% ../nbs/06_PINN_NF2_visualization.ipynb 15
class draw_grid:
    def __init__(self, grd):
        grid = copy.deepcopy(grd)
        self.grid = grid
        x_ind_min, y_ind_min, z_ind_min = 0, 0, 0
        Nx, Ny, Nz = self.grid.dimensions
        x_ind_max, y_ind_max, z_ind_max = Nx-1, Ny-1, Nz-1

        self.x_ind_min, self.y_ind_min, self.z_ind_min = x_ind_min, y_ind_min, z_ind_min
        self.x_ind_max, self.y_ind_max, self.z_ind_max = x_ind_max, y_ind_max, z_ind_max
        
        bottom_subset = (x_ind_min, x_ind_max, y_ind_min, y_ind_max, 0, 0)
        bottom = self.grid.extract_subset(bottom_subset).extract_surface()
        bottom.active_vectors_name = 'B'
        bottom.active_scalars_name = 'mag'

        self.bottom = bottom

        self.x_bottom = bottom.points[:, 0].reshape(Nx, Ny)
        self.y_bottom = bottom.points[:, 1].reshape(Nx, Ny)
        self.B_bottom = bottom['B'].reshape(Nx, Ny, 3)

        B = self.grid['B'].reshape(Nz, Ny, Nx, 3)
        self.B = B.transpose(2, 1, 0, 3)

    def plt_Bz(self):
        plt.close()
        fig, ax = plt.subplots(figsize=(6,6))
        CS = plt.contour(self.x_bottom, self.y_bottom, self.B_bottom[:, :, 2], 
                         origin='lower', colors='k')
        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.clabel(CS, fontsize=9, inline=True)
        ax.set_title(r"$B_z(z=0)$")
        plt.show()
    

    def k3d_bottom(self):
        p = pv.Plotter()
        p.show_bounds()
        p.add_mesh(self.grid.outline())
        p.add_mesh(self.bottom)
        p.show()

    def pv_bottom(self):
        p = pv.Plotter()
        p.show_bounds()
        p.add_mesh(self.grid.outline())
        p.add_mesh(self.bottom)
        p.show()

    def pv_Bz_2D(self):
        p = pv.Plotter()
        p.show_bounds()
        p.add_mesh(self.grid.outline())
        sargs = dict(title="B_z")
        ctr = self.bottom.contour(scalars=self.bottom['B'][:, 2])
        p.add_mesh(ctr, cmap='plasma', scalar_bar_args=sargs)
        p.show()

    def pv_Bz_3D(self):
        p = pv.Plotter()
        p.show_bounds()
        p.add_mesh(self.grid.outline())
        sargs = dict(title="B_z")
        ctr = self.grid.contour(scalars=self.grid['B'][:, 2])
        p.add_mesh(ctr, cmap='plasma', scalar_bar_args=sargs, opacity=0.5)
        p.show()

    def pv_streamline(self):
        p = pv.Plotter()
        p.show_bounds()
        p.add_mesh(self.grid.outline())
        i_size = self.grid.bounds[1]-self.grid.bounds[0]
        j_size = self.grid.bounds[3]-self.grid.bounds[2]
        seed = pv.Plane(center=(self.grid.center[0], self.grid.center[1], 0), direction=(0,0,1), 
                i_size=i_size, j_size=j_size, 
                i_resolution=10, j_resolution=10)
        p.add_mesh(seed)
        strl = self.grid.streamlines_from_source(seed,
                                                 vectors='B',
                                                 max_time=180,
                                                 initial_step_length=0.1,
                                                 integration_direction='both')
        
        p.add_mesh(strl.tube(radius=i_size/400), cmap='bwr', ambient=0.2)

        sargs = dict(title="B_z")
        ctr = self.bottom.contour(scalars=self.bottom['B'][:, 2])
        p.add_mesh(ctr, cmap='plasma', scalar_bar_args=sargs)
        p.show()

    def pv_streamline_Bz(self, camera_position=None, i_siz=None, j_siz=None, i_resolution=10, j_resolution=10, vmin=-2000, vmax=2000):
        p = pv.Plotter()
        p.show_bounds()
        p.add_mesh(self.grid.outline())
        sargs_B = dict(
            title='Bz [G]',
            title_font_size=15,
            height=0.25,
            width=0.05,
            vertical=True,
            position_x = 0.05,
            position_y = 0.05,
        )
        dargs_B = dict(
            scalars='B', 
            component=2, 
            clim=(vmin, vmax), 
            scalar_bar_args=sargs_B, 
            show_scalar_bar=True, 
            lighting=False
        )
        p.add_mesh(self.bottom, cmap='gray', **dargs_B)

        if (i_siz is not None) and (j_siz is not None):
            i_size = i_siz
            j_size = j_siz
        else:
            i_size = self.grid.bounds[1]-self.grid.bounds[0]
            j_size = self.grid.bounds[3]-self.grid.bounds[2]
        seed = pv.Plane(center=(self.grid.center[0], self.grid.center[1], 0), direction=(0,0,1), 
                i_size=i_size, j_size=j_size, 
                i_resolution=i_resolution, j_resolution=j_resolution)
        # p.add_mesh(seed)
        strl = self.grid.streamlines_from_source(seed,
                                                 vectors='B',
                                                 max_time=180,
                                                 initial_step_length=0.1,
                                                 integration_direction='both')
        
        p.add_mesh(strl.tube(radius=i_size/400), 
                   lighting=False,
                   color='blue')
        if camera_position is not None:
             p.camera_position = camera_position
        p.show()

    def plt_Bz_imshow(self, z=0, vmin=None, vmax=None):         
        plt.close()
        fig, ax = plt.subplots(figsize=(6,6))
        if (vmin is not None) and (vmax is not None):
            CS = plt.imshow(self.B[:, :, z, 2].transpose(), origin='lower', cmap='gray', vmin=vmin, vmax=vmax)
        else:
            CS = plt.imshow(self.B[:, :, z, 2].transpose(), origin='lower', cmap='gray')
        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.set_title(f"B_z(z={z})")
        fig.colorbar(CS)
        plt.show()
