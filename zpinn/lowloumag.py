# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_lowlou_mag_func.ipynb.

# %% auto 0
__all__ = ['LowLouMag']

# %% ../nbs/03_lowlou_mag_func.ipynb 2
import numpy as np
import pyvista as pv
from fastcore.basics import *
from .lowlouode import find_P_and_a2

# %% ../nbs/03_lowlou_mag_func.ipynb 9
class LowLouMag:
    "A Low and Lou (1990) NLFFF"
    def __init__(self, 
                 bounds=[-1,1,-1,1,0,2],
                 resolutions=[64,64,64],
                 n=1, m=1,
                 l=0.3, Phi=np.pi/2):
        self.bounds = bounds
        self.resolutions = resolutions
        self.n = n
        self.m = m
        self.l = l
        self.Phi = Phi
    def __str__(self): 
        return (
            "### Low and Lou (1990) NLFFF\n"
            f"bounds = {self.bounds}<br>\n"
            f"resolutions = {self.resolutions}<br>\n"
            f"n = {self.n}<br>\n"
            f"m = {self.m}<br>\n"
            f"l = {self.l}<br>\n"
            f"Phi = {self.Phi}<br>\n"
        )
    _repr_markdown_ = __str__

# %% ../nbs/03_lowlou_mag_func.ipynb 11
@patch_to(LowLouMag)
def create_physical_coordinates(self):
    x_1D = np.linspace(self.bounds[0], self.bounds[1], self.resolutions[0])
    y_1D = np.linspace(self.bounds[2], self.bounds[3], self.resolutions[1])
    z_1D = np.linspace(self.bounds[4], self.bounds[5], self.resolutions[2])
    x_spacing = np.diff(x_1D)[0]
    y_spacing = np.diff(y_1D)[0]
    z_spacing = np.diff(z_1D)[0]
    spacing = (x_spacing, y_spacing, z_spacing)
    origin = (x_1D[0], y_1D[0], z_1D[0]) # The bottom left corner of the data set
    self.grid = pv.ImageData(dimensions=self.resolutions, spacing=spacing, origin=origin)
    return self.grid

# %% ../nbs/03_lowlou_mag_func.ipynb 14
@patch_to(LowLouMag)
def calculate_local_Cartesian_coordinates(self):
    # information of point source & Z-axis
    l = self.l
    Phi = self.Phi
    
    # physical coordinates (x, y, z)
    x = self.grid.x
    y = self.grid.y
    z = self.grid.z

    # local Cartesian coordinates (X, Y, Z)
    X = x*np.cos(Phi) - (z+l)*np.sin(Phi)
    Y = y
    Z = x*np.sin(Phi) + (z+l)*np.cos(Phi)

    self.X, self.Y, self.Z = X, Y, Z

# %% ../nbs/03_lowlou_mag_func.ipynb 19
@patch_to(LowLouMag)
def calculate_local_spherical_coordinates(self):
    # local Cartesian coordinates (X, Y, Z)
    X = self.X
    Y = self.Y
    Z = self.Z

    # local spherical coordinates (r, theta, phi)
    r = np.sqrt(X**2 + Y**2 + Z**2)
    theta = np.arccos(Z/r)
    phi = np.arctan2(Y, X) 

    self.r, self.theta, self.phi = r, theta, phi

# %% ../nbs/03_lowlou_mag_func.ipynb 23
@patch_to(LowLouMag)
def calculate_eigenfunctions(self):
    # calculate mu=cos(theta)
    mu = np.cos(self.theta)

    # eigenfunction parameter n, m
    n = self.n
    m = self.m

    # calculate eigenfunction & its derivates and eigenvalues
    # S = [P, dP]
    S, a2 = find_P_and_a2(n, m)
    P, dP = S(mu)

    self.P, self.dP, self.a2 = P, dP, a2

# %% ../nbs/03_lowlou_mag_func.ipynb 28
@patch_to(LowLouMag)
def calculate_local_spherical_magnetic_fields(self):
    # eigenfunctions and eigenvalue
    n, m = self.n, self.m
    P, dP, a2 = self.P, self.dP, self.a2

    # r, theta info
    r, theta = self.r, self.theta
    
    A = r**(-n) * P
    dA_dtheta = -r**(-n) * np.sin(theta) * dP
    dA_dr = -n*r**(-n-1) * P
    Q = np.sqrt(a2) * A ** (1 + 1 / n)
    # Q = np.sqrt(a2) * A * np.abs(A)**(1/n)
    
    alpha = np.sqrt(a2) * (1 + 1/n) * A**(1/n)
    
    Br = (r**2 * np.sin(theta))**(-1) * dA_dtheta
    Btheta = -1 * (r*np.sin(theta))**(-1) * dA_dr
    Bphi = (r*np.sin(theta))**(-1) * Q
    
    self.Br, self.Btheta, self.Bphi, self.alpha = Br, Btheta, Bphi, alpha

# %% ../nbs/03_lowlou_mag_func.ipynb 31
@patch_to(LowLouMag)
def calculate_local_Cartesian_magnetic_fields(self):
    Br, Btheta, Bphi = self.Br, self.Btheta, self.Bphi
    r, theta, phi = self.r, self.theta, self.phi
    
    BX = Br * np.sin(theta) * np.cos(phi) + Btheta * np.cos(theta) * np.cos(phi) - Bphi * np.sin(phi)
    BY = Br * np.sin(theta) * np.sin(phi) + Btheta * np.cos(theta) * np.sin(phi) + Bphi * np.cos(phi)
    BZ = Br * np.cos(theta) - Bphi * np.sin(theta)
    
    self.BX, self.BY, self.BZ = BX, BY, BZ

# %% ../nbs/03_lowlou_mag_func.ipynb 34
@patch_to(LowLouMag)
def calculate_physical_magnetic_fields(self):
    BX, BY, BZ = self.BX, self.BY, self.BZ
    Phi = self.Phi

    Bx = BX * np.cos(Phi) + BZ * np.sin(Phi)
    By = BY
    Bz = - BX * np.sin(Phi) + BZ * np.cos(Phi)
    
    self.Bx, self.By, self.Bz = Bx, By, Bz

# %% ../nbs/03_lowlou_mag_func.ipynb 38
@patch_to(LowLouMag)
def add_magnetic_field_to_grid(self):
    vectors = np.empty((self.grid.n_points, 3))
    vectors[:, 0] = self.Bx
    vectors[:, 1] = self.By
    vectors[:, 2] = self.Bz
    self.grid['B'] = vectors
    self.grid.active_vectors_name = 'B'
    magnitude = np.linalg.norm(vectors, axis=-1)
    self.grid['mag'] = magnitude
    self.grid.active_scalars_name = 'mag'
    self.grid['alpha'] = self.alpha

# %% ../nbs/03_lowlou_mag_func.ipynb 39
@patch_to(LowLouMag)
def create_bottom_boundary(self):
    Nx, Ny, _ =  self.grid.dimensions
    bottom_subset = (0, Nx-1, 0, Ny-1, 0, 0)
    self.bottom = self.grid.extract_subset(bottom_subset).extract_surface()
    self.b_bottom = self.bottom['B'].reshape(Nx, Ny, 3)
    self.b_bottom = np.array(self.b_bottom)

# %% ../nbs/03_lowlou_mag_func.ipynb 40
@patch_to(LowLouMag)
def calculate(self):
    self.create_physical_coordinates()
    self.calculate_local_Cartesian_coordinates()
    self.calculate_local_spherical_coordinates()
    self.calculate_eigenfunctions()
    self.calculate_local_spherical_magnetic_fields()
    self.calculate_local_Cartesian_magnetic_fields()
    self.calculate_physical_magnetic_fields()
    self.add_magnetic_field_to_grid()
    self.create_bottom_boundary()
    return self.grid
