# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_lowlou_ODE.ipynb.

# %% auto 0
__all__ = ['find_P_and_a2']

# %% ../nbs/01_lowlou_ODE.ipynb 21
import numpy as np 
from scipy.integrate import solve_bvp

# %% ../nbs/01_lowlou_ODE.ipynb 24
def find_P_and_a2(n, m):

    # ODE system
    # Define BVP (Low and Lou 1990)
    # a2 -> eigenvalue
    # S = [P, dP/dmu]
    # F = dSdmu
    # 
    # dP/dmu = 10 at mu = -1
    def F(x, y, p):
        mu = x
        P = y[0]
        dP = y[1]
        a2 = p[0]

        ddP = (-1)*(n*(n+1)*P + a2*((1+n)/n)*P**(1+2/n)) / (1-mu**2 + 1e-6)

        return [dP, ddP] 

    # Boundary Condition
    def bc(ya, yb, p):
        return [ya[0], ya[1]-10, yb[0]]

    # Domain
    mu_span = [-1, 1]
    N = 100
    mu = np.linspace(mu_span[0], mu_span[1], N)

    # Initial guess
    # For given m, use different initial guess
    if m % 2 == 0:
        P_guess = np.cos(mu * (m + 1) * np.pi / 2)
    else:
        P_guess = np.sin(mu * (m + 1) * np.pi / 2)

    # For initial guess of dP/dmu, just use BC value
    dP_guess = 10*np.ones_like(mu)

    y_guess = np.vstack([P_guess, dP_guess])

    # For each initial eigenvalue, solve the problem.
    # If it is successful, return that otherwise do not return.
    # np.vectorize -> for loop & return type : array
    @np.vectorize
    def solve_eigenvalue_problem(a2_0):
        sol = solve_bvp(F, bc, mu, y_guess, p=[a2_0], tol=1e-6)
        if sol.success == True:
            return sol
        else:
            return None 

    a2_0_list = np.linspace(0.0, 10.0, 100)

    results = solve_eigenvalue_problem(a2_0_list)
    eigenvalues = np.array([sol.p for sol in results if sol is not None])


     # round & unique value & sorting
    eigenvalues = np.sort(np.unique(np.round(eigenvalues, 4)))
    
    # The smallest value for given m is desired eigenvalue
    eigenvalue = eigenvalues[0]
    # If this eigenvalue is zero for nonzero m, choose the next big eigenvalue
    if m > 0:
        if not (eigenvalue > 0):
            eigenvalue = eigenvalues[1]

    # Solve again with that eigenvalue
    sol = solve_eigenvalue_problem([eigenvalue])[0]
    
    return sol.sol, sol.p[0]
